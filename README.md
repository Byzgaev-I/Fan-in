# Fan-in


## Описание задания
Вам необходимо реализовать эмулятор системы мониторинга производительности, которая собирает метрики от трёх независимых источников данных и объединяет их в единый поток для дальнейшей обработки.   

Система должна включать:  

Три функции-генератора метрик, каждая из которых эмулирует различный источник данных.  
Функцию fanIn, которая объединяет все источники в один канал.  
Главную функцию, которая обрабатывает объединённый поток данных.  
 
Структура метрики:  

type Metric struct {
Source string // название источника: строго “CPU”, “Memory” или "Network"
Value float64 // значение метрики (случайное число в определенном диапазоне)
Time time.Time // время создания метрики (time.Now())
}

### Инструкция к выполнению  

Создайте структуру Metric с тремя полями: Source (string), Value (float64) и Time (time.Time).

Реализуйте три функции-генератора эмуляторов метрик:

### cpuMetrics() <-chan Metric
o Эмулирует метрики загрузки процессора
o Генерирует ровно 5 метрик с интервалом 800 миллисекунд между отправками
o Source должно быть строго «CPU»
o Value должно быть случайным числом от 0 до 100 (процент загрузки)
o Time должно быть текущим временем (time.Now())

### memoryMetrics() <-chan Metric  
o Эмулирует метрики использования памяти  
o Генерирует ровно 5 метрик с интервалом 1200 миллисекунд между отправками  
o Source должно быть строго «Memory»  
o Value должно быть случайным числом от 0 до 16384 (использование памяти в мегабайтах)  
o Time должно быть текущим временем (time.Now())  

### networkMetrics() <-chan Metric  
o Эмулирует метрики сетевой активности  
o Генерирует ровно 5 метрик с интервалом 1500 миллисекунд между отправками  
o Source должно быть строго «Network»  
o Value должно быть случайным числом от 0 до 1000 (пропускная способность в мегабитах в секунду)  
o Time должно быть текущим временем (time.Now())   

### Требования к каждому генератору:
· Создать небуферизованный канал типа chan Metric
· Запустить горутину, которая будет отправлять метрики в канал
· Использовать math/rand.Float64() для генерации случайных значений
· Использовать time.Sleep() для создания интервалов между отправками
· Обязательно закрыть канал с помощью defer close(ch) после отправки всех метрик
· Вернуть канал только для чтения (<-chan Metric)

### Реализуйте функцию fanIn(channels …<-chan Metric) <-chan Metric:
· Принимает переменное количество каналов-источников (только для чтения)
· Создаёт один выходной канал типа chan Metric
· Для каждого входного канала запускает отдельную горутину
· Каждая горутина копирует все значения из своего входного канала в общий выходной канал
· Использует sync.WaitGroup для подсчета активных горутин
· После завершения всех горутин закрывает выходной канал
· Возвращает канал только для чтения (<-chan Metric)

### Обязательная последовательность в fanIn:
· Создать выходной канал
· Создать sync.WaitGroup
· Для каждого входного канала: вызвать wg.Add(1) и запустить горутину
· В каждой горутине: использовать defer wg.Done() и цикл for range для копирования
· Запустить отдельную горутину, которая ждёт wg.Wait() и затем закрывает выходной канал

### В функции main():
· Инициализировать генератор случайных чисел: rand.Seed(time.Now().UnixNano())
· Вывести сообщение о запуске системы мониторинга
· Создать три канала, вызвав cpuMetrics(), memoryMetrics(), networkMetrics()
· Передать все три канала в функцию fanIn
· Получить объединённый канал от fanIn
· В цикле for metric := range объединённый канал прочитать все метрики
· Вывести каждую метрику в точном формате: «Источник: [Source], Значение: [Value], Время: [Time]»
· После завершения цикла вывести сообщение о завершении мониторинга

### Проверьте корректность работы:
· Программа должна вывести ровно 15 метрик (5 от CPU + 5 от Memory + 5 от Network)
· Программа должна завершиться автоматически без зависаний
· Метрики могут выводиться в любом порядке (это особенность параллельной обработки)
· Не должно быть ошибок типа «deadlock» или «panic»

### Ожидаемый результат работы программы:
Запуск системы мониторинга…
Источник: CPU, Значение: 45.67, Время: 15:30:15.123
Источник: Memory, Значение: 8192.34, Время: 15:30:15.456
Источник: Network, Значение: 567.89, Время: 15:30:15.789
… (еще 12 метрик в произвольном порядке)
Мониторинг завершен.

Прикрепите файл main.go с кодом программы и нажмите «Отправить на проверку». Перед отправкой домашнего задания вы можете написать комментарий эксперту.

Критерии оценки домашнего задания
«Зачёт»
· Реализовали все требуемые функции точно согласно спецификации
· Программа выводит ровно 15 метрик от всех трёх источников
· Программа корректно завершается без зависаний и ошибок
· Код содержит осмысленные комментарии к ключевым участкам
· Проведено тестирование программы командой go run main.go
· Имена источников метрик точно соответствуют требованиям: «CPU», «Memory», «Network»
· Диапазоны значений метрик соответствуют указанным

## Выполнение 

### Код: 

```go
package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

// Metric - структура для хранения одной метрики
type Metric struct {
	Source string    // Название источника: "CPU", "Memory" или "Network"
	Value  float64   // Значение метрики (случайное число)
	Time   time.Time // Время создания метрики
}

// cpuMetrics - эмулятор метрик загрузки процессора
func cpuMetrics() <-chan Metric {
	// Создаем небуферизованный канал
	ch := make(chan Metric)

	// Запускаем горутину (параллельный поток)
	go func() {
		// defer гарантирует, что канал закроется после выхода из функции
		defer close(ch)

		// Генерируем ровно 5 метрик
		for i := 0; i < 5; i++ {
			// Создаем метрику
			metric := Metric{
				Source: "CPU",                // Название источника
				Value:  rand.Float64() * 100, // Случайное число от 0 до 100
				Time:   time.Now(),           // Текущее время
			}

			// Отправляем метрику в канал
			ch <- metric

			// Ждем 800 миллисекунд перед следующей отправкой
			time.Sleep(800 * time.Millisecond)
		}
	}()

	// Возвращаем канал только для чтения
	return ch
}

// memoryMetrics - эмулятор метрик использования памяти
func memoryMetrics() <-chan Metric {
	ch := make(chan Metric)

	go func() {
		defer close(ch)

		// Генерируем ровно 5 метрик
		for i := 0; i < 5; i++ {
			metric := Metric{
				Source: "Memory",               // Название источника
				Value:  rand.Float64() * 16384, // Случайное число от 0 до 16384 МБ
				Time:   time.Now(),
			}

			ch <- metric

			// Ждем 1200 миллисекунд (1.2 секунды)
			time.Sleep(1200 * time.Millisecond)
		}
	}()

	return ch
}

// networkMetrics - эмулятор метрик сетевой активности
func networkMetrics() <-chan Metric {
	ch := make(chan Metric)

	go func() {
		defer close(ch)

		// Генерируем ровно 5 метрик
		for i := 0; i < 5; i++ {
			metric := Metric{
				Source: "Network",             // Название источника
				Value:  rand.Float64() * 1000, // Случайное число от 0 до 1000 Мбит/с
				Time:   time.Now(),
			}

			ch <- metric

			// Ждем 1500 миллисекунд (1.5 секунды)
			time.Sleep(1500 * time.Millisecond)
		}
	}()

	return ch
}

// fanIn - объединяет несколько каналов в один (паттерн Fan-in)
func fanIn(channels ...<-chan Metric) <-chan Metric {
	// Создаем выходной канал, куда будем собирать все метрики
	out := make(chan Metric)

	// WaitGroup помогает дождаться завершения всех горутин
	var wg sync.WaitGroup

	// Для каждого входного канала создаем отдельную горутину
	for _, ch := range channels {
		// Увеличиваем счетчик горутин
		wg.Add(1)

		// Запускаем горутину для этого канала
		go func(c <-chan Metric) {
			// Уменьшаем счетчик при завершении горутины
			defer wg.Done()

			// Читаем все данные из входного канала
			// и отправляем их в выходной канал
			for metric := range c {
				out <- metric
			}
		}(ch) // Передаем канал в горутину
	}

	// Запускаем отдельную горутину для закрытия выходного канала
	go func() {
		// Ждем завершения всех горутин
		wg.Wait()
		// Закрываем выходной канал после завершения всех источников
		close(out)
	}()

	// Возвращаем канал только для чтения
	return out
}

// main - главная функция программы
func main() {
	// Инициализируем генератор случайных чисел
	rand.Seed(time.Now().UnixNano())

	// Выводим сообщение о запуске
	fmt.Println("Запуск системы мониторинга...")

	// Создаем три канала от разных источников
	cpuCh := cpuMetrics()
	memoryCh := memoryMetrics()
	networkCh := networkMetrics()

	// Объединяем все три канала в один с помощью fanIn
	mergedCh := fanIn(cpuCh, memoryCh, networkCh)

	// Читаем все метрики из объединенного канала
	// Цикл завершится автоматически, когда канал закроется
	for metric := range mergedCh {
		// Выводим метрику в требуемом формате
		fmt.Printf("Источник: %s, Значение: %.2f, Время: %s\n",
			metric.Source,
			metric.Value,
			metric.Time.Format("15:04:05.000"))
	}

	// Выводим сообщение о завершении
	fmt.Println("Мониторинг завершен.")
}

```

### 1 cpuMetrics() - ПОЛНОСТЬЮ СООТВЕТСТВУЕТ

```go
func cpuMetrics() <-chan Metric {
    ch := make(chan Metric)              // Небуферизованный канал
    go func() {                          // Горутина
        defer close(ch)                  // defer close(ch)
        for i := 0; i < 5; i++ {         // 5 метрик
            metric := Metric{
                Source: "CPU",           // Строго "CPU"
                Value: rand.Float64() * 100,  //  0-100
                Time: time.Now(),        // time.Now()
            }
            ch <- metric
            time.Sleep(800 * time.Millisecond) // 800 мс
        }
    }()
    return ch                            // <-chan Metric
}

```

### 2 memoryMetrics() - ПОЛНОСТЬЮ СООТВЕТСТВУЕТ

```go
func memoryMetrics() <-chan Metric {
    ch := make(chan Metric)              // Небуферизованный канал
    go func() {                          // Горутина
        defer close(ch)                  // defer close(ch)
        for i := 0; i < 5; i++ {         // 5 метрик
            metric := Metric{
                Source: "Memory",        // Строго "Memory"
                Value: rand.Float64() * 16384, // 0-16384
                Time: time.Now(),        // time.Now()
            }
            ch <- metric
            time.Sleep(1200 * time.Millisecond) // 1200 мс
        }
    }()
    return ch                            // <-chan Metric
}
```





